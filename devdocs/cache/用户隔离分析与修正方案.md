# DKI ç¼“å­˜ç³»ç»Ÿç”¨æˆ·éš”ç¦»åˆ†æä¸ä¿®æ­£æ–¹æ¡ˆ

> ç‰ˆæœ¬: 1.0  
> æ—¥æœŸ: 2026-02-17  
> èŒƒå›´: `dki/cache/*`, `dki/core/dki_system.py`, `dki/core/dki_plugin.py`, `dki/core/plugin/injection_executor.py`, `dki/core/components/session_kv_cache.py`, `dki/core/components/tiered_kv_cache.py`, `dki/core/components/hybrid_injector.py`, `dki/core/memory_router.py`

---

## ä¸€ã€åˆ†ææ–¹æ³•è®º

ç”¨æˆ·éš”ç¦»çš„ä¸‰å±‚æ¨¡å‹:

| å±‚æ¬¡ | å«ä¹‰ | æ£€éªŒæ ‡å‡† |
|------|------|---------|
| **æ•°æ®éš”ç¦»** | ä¸åŒç”¨æˆ·çš„æ•°æ®ç‰©ç†/é€»è¾‘åˆ†ç¦» | å³ä½¿é”®åè¢«çŒœåˆ°/æ‹¼é”™ï¼Œä¹Ÿæ‹¿ä¸åˆ°ä»–äººæ•°æ® |
| **è®¡ç®—éš”ç¦»** | ä¸åŒç”¨æˆ·çš„è®¡ç®—è¿‡ç¨‹äº’ä¸å½±å“ | ç”¨æˆ· A çš„æ¨ç†æ®‹ç•™ä¸ä¼šæ³„éœ²ç»™ç”¨æˆ· B |
| **æƒé™éš”ç¦»** | æ•°æ®è®¿é—®éœ€ç»è¿‡èº«ä»½é‰´æƒ + æƒé™æ ¡éªŒ | è¶Šæƒè®¿é—®è¢«æ‹¦æˆªå¹¶å®¡è®¡ |

---

## äºŒã€é€ç»„ä»¶éš”ç¦»ç°çŠ¶åˆ†æ

### 2.1 `PreferenceCacheManager` (preference_cache.py)

**ç¼“å­˜æ± ç»“æ„:**

```
L1 (å†…å­˜): LRUCache._cache: OrderedDict[str, CacheEntry]
    é”®æ ¼å¼: "{user_id}:{preference_hash}"
    ä¾‹: "user_123:a1b2c3d4e5f6g7h8"

L2 (Redis): DKIRedisClient
    é”®æ ¼å¼: "dki:pref_kv:{user_id}:{preference_hash}"
    ä¾‹: "dki:pref_kv:user_123:a1b2c3d4e5f6g7h8"
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 1 | **L1 å…¨å±€å…±äº«æ± ** | ğŸ”´ é«˜ | `LRUCache` æ˜¯è¿›ç¨‹çº§å•ä¾‹ï¼Œæ‰€æœ‰ç”¨æˆ·çš„ K/V tensor å­˜äºåŒä¸€ä¸ª `OrderedDict`ã€‚æ— è®¿é—®æƒé™æ ¡éªŒï¼Œä»»ä½•èƒ½è°ƒç”¨ `_l1_cache.get(key)` çš„ä»£ç è·¯å¾„ï¼Œåªè¦æ„é€ å‡ºæ­£ç¡®çš„ keyï¼Œå°±èƒ½è¯»å–ä»»æ„ç”¨æˆ·çš„ç¼“å­˜ã€‚ |
| 2 | **L2 Redis å…¨å±€å‘½åç©ºé—´** | ğŸ”´ é«˜ | æ‰€æœ‰ç”¨æˆ·çš„ K/V å­˜äºåŒä¸€ä¸ª Redis dbï¼ˆé»˜è®¤ db=0ï¼‰ï¼Œå‰ç¼€ `dki:pref_kv` æ˜¯å›ºå®šçš„ã€‚æ—  Redis ACL ç”¨æˆ·çº§éš”ç¦»ã€‚`SCAN` + `GET` å¯éå†å…¨éƒ¨ç”¨æˆ·ç¼“å­˜ã€‚ |
| 3 | **preference_hash å¯é¢„æµ‹** | ğŸŸ¡ ä¸­ | `_compute_preference_hash` ä½¿ç”¨ `md5(text)[:16]`ã€‚åå¥½æ–‡æœ¬é€šå¸¸æ˜¯çŸ­æ–‡æœ¬ï¼ˆå¦‚"ç´ é£Ÿä¸»ä¹‰è€…"ï¼‰ï¼ŒMD5 æ— ç›å€¼ï¼Œæ”»å‡»è€…å¯ç©·ä¸¾å¸¸è§åå¥½æ–‡æœ¬å¾—åˆ° hashã€‚ |
| 4 | **user_id æ— éªŒè¯** | ğŸ”´ é«˜ | `get_preference_kv(user_id, ...)` ä¸éªŒè¯è°ƒç”¨è€…æ˜¯å¦æœ‰æƒè®¿é—®è¯¥ user_idã€‚ä»»ä½•ä¼ å…¥æ­£ç¡® user_id çš„è°ƒç”¨éƒ½èƒ½è·å–ç¼“å­˜ã€‚ |
| 5 | **invalidate æ— é‰´æƒ** | ğŸŸ¡ ä¸­ | `invalidate(user_id)` å¯æ¸…é™¤ä»»æ„ç”¨æˆ·ç¼“å­˜ï¼Œæ— æƒé™æ ¡éªŒã€‚æ¶æ„è°ƒç”¨å¯å¯¼è‡´å…¶ä»–ç”¨æˆ·çš„ç¼“å­˜è¢«æ¸…é™¤ï¼ˆDoSï¼‰ã€‚ |
| 6 | **warm_cache æ‰¹é‡æš´éœ²** | ğŸŸ¡ ä¸­ | `warm_cache(user_ids, ...)` æ¥å—ä»»æ„ user_id åˆ—è¡¨ï¼Œæ— æ ¡éªŒã€‚ |

**ä»£ç è¯æ®:**

```python
# preference_cache.py L291-293
def _make_cache_key(self, user_id: str, preference_hash: str) -> str:
    return f"{user_id}:{preference_hash}"
    # âš  æ—  token/ç­¾å/åŠ å¯†ï¼Œçº¯å­—ç¬¦ä¸²æ‹¼æ¥
```

```python
# preference_cache.py L113-126
async def get(self, key: str) -> Optional[CacheEntry]:
    async with self._lock:
        if key in self._cache:
            self._cache.move_to_end(key)
            entry = self._cache[key]
            # âš  æ— è°ƒç”¨è€…èº«ä»½æ ¡éªŒï¼Œä»»ä½•çŸ¥é“ key çš„ä»£ç éƒ½èƒ½è¯»å–
            return entry
```

---

### 2.2 `InjectionExecutor._preference_kv_cache` (injection_executor.py)

**ç¼“å­˜æ± ç»“æ„:**

```
å†…å­˜: Dict[str, Tuple[Any, str]]
    é”®æ ¼å¼: "{user_id}:{md5(preference_text)}"
    ä¾‹: "user_123:a1b2c3d4e5f6g7h8..."
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 7 | **Executor çº§å…¨å±€ dict** | ğŸ”´ é«˜ | `self._preference_kv_cache` æ˜¯ `InjectionExecutor` å®ä¾‹çš„ `Dict`ã€‚åœ¨ `DKIPlugin` ä¸­ï¼Œæ‰€æœ‰ç”¨æˆ·å…±äº«åŒä¸€ä¸ª `_executor` å®ä¾‹ï¼Œå› æ­¤å…±äº«åŒä¸€ä¸ªç¼“å­˜æ± ã€‚ |
| 8 | **æ— å¹¶å‘ä¿æŠ¤** | ğŸŸ¡ ä¸­ | `Dict` éçº¿ç¨‹å®‰å…¨ã€‚åœ¨å¼‚æ­¥ç¯å¢ƒä¸­ï¼Œå¹¶å‘è¯·æ±‚å¯èƒ½å¯¼è‡´è¯»å†™å†²çªï¼ˆè™½ç„¶ CPython GIL æä¾›äº†éƒ¨åˆ†ä¿æŠ¤ï¼Œä½†åœ¨ asyncio + å¤šçº¿ç¨‹åœºæ™¯ä¸‹ä¸å®‰å…¨ï¼‰ã€‚ |
| 9 | **æ— å¤§å°é™åˆ¶** | ğŸŸ¡ ä¸­ | `_preference_kv_cache` æ—  `maxsize`ï¼Œéšç”¨æˆ·å¢é•¿æ— é™è†¨èƒ€ã€‚æ—  LRU/TTL é©±é€ç­–ç•¥ã€‚ |

**ä»£ç è¯æ®:**

```python
# injection_executor.py L96
self._preference_kv_cache: Dict[str, Tuple[Any, str]] = {}
# âš  å…¨å±€ dictï¼Œæ— å¤§å°é™åˆ¶ï¼Œæ— æƒé™æ ¡éªŒ

# injection_executor.py L554-555
content_hash = hashlib.md5(preference_text.encode()).hexdigest()
cache_key = f"{user_id}:{content_hash}"
# âš  é”®å¯é¢„æµ‹ï¼Œæ—  HMAC/ç­¾å
```

---

### 2.3 `HybridDKIInjector._preference_cache` (hybrid_injector.py)

**ç¼“å­˜æ± ç»“æ„:**

```
å†…å­˜: Dict[str, Any]
    é”®æ ¼å¼: "{user_id}:{hash(content)}"
    ä¾‹: "user_123:8374629401"
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 10 | **ç¬¬ä¸‰ä¸ªå…¨å±€ç¼“å­˜æ± ** | ğŸŸ¡ ä¸­ | `HybridDKIInjector` ç»´æŠ¤äº†ç‹¬ç«‹çš„ `_preference_cache`ï¼Œä¸ `PreferenceCacheManager` å’Œ `InjectionExecutor._preference_kv_cache` å½¢æˆä¸‰å¥—ç‹¬ç«‹ä½†åŒè´¨çš„ç¼“å­˜ã€‚æ•°æ®ä¸€è‡´æ€§æ— ä¿è¯ã€‚ |
| 11 | **Python `hash()` ä¸ç¨³å®š** | ğŸŸ¡ ä¸­ | ä½¿ç”¨ `hash(preference.content)` ä½œä¸ºé”®çš„ä¸€éƒ¨åˆ†ã€‚Python 3 çš„ `hash()` åœ¨ä¸åŒè¿›ç¨‹é—´ä¸ä¸€è‡´ï¼ˆPYTHONHASHSEEDï¼‰ï¼Œå¯¼è‡´å¤šå®ä¾‹éƒ¨ç½²æ—¶ç¼“å­˜é”®ä¸å¯é¢„æµ‹ã€‚ |

**ä»£ç è¯æ®:**

```python
# hybrid_injector.py L173
self._preference_cache: Dict[str, Any] = {}

# hybrid_injector.py L360
cache_key = f"{preference.user_id}:{hash(preference.content)}"
# âš  hash() è·¨è¿›ç¨‹ä¸ç¨³å®šï¼Œä¸”æ— æƒé™æ ¡éªŒ
```

---

### 2.4 `DKISystem._user_preferences` (dki_system.py)

**ç¼“å­˜æ± ç»“æ„:**

```
å†…å­˜: Dict[str, UserPreference]
    é”®: user_id
    å€¼: UserPreference(content, user_id, metadata)
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 12 | **æ˜æ–‡åå¥½å…¨å±€å­˜å‚¨** | ğŸ”´ é«˜ | `_user_preferences` ä»¥æ˜æ–‡å­˜å‚¨æ‰€æœ‰æ´»è·ƒç”¨æˆ·çš„åå¥½æ–‡æœ¬ã€‚è¿›ç¨‹å†…ä»»ä½•ä»£ç è·¯å¾„å¯é€šè¿‡ `get_user_preference(user_id)` è¯»å–ä»»æ„ç”¨æˆ·çš„åå¥½ã€‚ |
| 13 | **æ— è¿‡æœŸ/é©±é€** | ğŸŸ¡ ä¸­ | åå¥½åŠ è½½åæ°¸ä¸è¿‡æœŸï¼Œéšç”¨æˆ·å¢é•¿æ— é™è†¨èƒ€ã€‚ |
| 14 | **set_user_preference æ— é‰´æƒ** | ğŸŸ¡ ä¸­ | å…¬å¼€æ–¹æ³•ï¼Œå¯è¢«ä»»æ„è°ƒç”¨è€…è®¾ç½®ä»»æ„ç”¨æˆ·çš„åå¥½ã€‚ |

**ä»£ç è¯æ®:**

```python
# dki_system.py L256
self._user_preferences: Dict[str, UserPreference] = {}
# âš  å…¨å±€ dictï¼Œæ˜æ–‡å­˜å‚¨

# dki_system.py L582
self._user_preferences[user_id] = UserPreference(
    content=preference_text,
    user_id=user_id,
    # âš  æ— åŠ å¯†ï¼Œæ— è®¿é—®æ§åˆ¶
)
```

---

### 2.5 `SessionKVCache` (session_kv_cache.py)

**ç¼“å­˜æ± ç»“æ„:**

```
å†…å­˜: OrderedDict[str, CachedKV]
    é”®æ ¼å¼: "{memory_id}" æˆ– "{memory_id}:{query_hash}"
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 15 | **æŒ‰ session_id åˆ†ç¦» âœ…** | âœ… ä½ | `DKISystem` ä¸ºæ¯ä¸ª session_id åˆ›å»ºç‹¬ç«‹çš„ `SessionKVCache` å®ä¾‹ (`_session_caches[session_id]`)ã€‚è¿™æ˜¯**æ­£ç¡®çš„éš”ç¦»ç²’åº¦**ã€‚ |
| 16 | **session_id æ— æ‰€æœ‰æƒæ ¡éªŒ** | ğŸŸ¡ ä¸­ | è™½ç„¶ cache æŒ‰ session åˆ†ç¦»ï¼Œä½† `_get_session_cache(session_id)` ä¸éªŒè¯ session_id æ˜¯å¦å±äºå½“å‰ user_idã€‚ç”¨æˆ· A å¦‚æœçŸ¥é“ç”¨æˆ· B çš„ session_idï¼Œç†è®ºä¸Šå¯è®¿é—® B çš„ session cacheã€‚ |

**ä»£ç è¯æ®:**

```python
# dki_system.py L470-491
def _get_session_cache(self, session_id: str) -> Union[SessionKVCache, TieredKVCache]:
    if self._use_tiered_cache:
        if session_id not in self._tiered_caches:
            self._tiered_caches[session_id] = TieredKVCache(...)
        return self._tiered_caches[session_id]
    else:
        if session_id not in self._session_caches:
            self._session_caches[session_id] = SessionKVCache()
        return self._session_caches[session_id]
    # âš  ä¸éªŒè¯ session_id æ˜¯å¦å±äºè¯·æ±‚çš„ user_id
```

---

### 2.6 `TieredKVCache` (tiered_kv_cache.py)

**ç¼“å­˜æ± ç»“æ„:**

```
L1 (GPU): OrderedDict[str, TieredCacheEntry]
L2 (CPU): OrderedDict[str, TieredCacheEntry]
L3 (SSD): æ–‡ä»¶ç³»ç»Ÿ ./data/kv_cache/{session_id}/{hash}.pkl
L4 (Text): Dict[str, str]
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 17 | **æŒ‰ session_id å®ä¾‹åŒ– âœ…** | âœ… ä½ | ä¸ `SessionKVCache` ç›¸åŒï¼Œæ¯ä¸ª session ç‹¬ç«‹å®ä¾‹ã€‚ |
| 18 | **L3 æ–‡ä»¶è·¯å¾„å¯éå†** | ğŸŸ¡ ä¸­ | SSD ç¼“å­˜ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿè·¯å¾„ `./data/kv_cache/{session_id}/`ã€‚å¦‚æœæœåŠ¡å™¨æ–‡ä»¶ç³»ç»Ÿæƒé™é…ç½®ä¸å½“ï¼Œå…¶ä»–è¿›ç¨‹/ç”¨æˆ·å¯éå†è¯»å–ã€‚ |
| 19 | **pickle ååºåˆ—åŒ–é£é™©** | ğŸŸ¡ ä¸­ | L2/L3 ä½¿ç”¨ `pickle.loads()` ååºåˆ—åŒ–ã€‚å¦‚æœ SSD æ–‡ä»¶è¢«ç¯¡æ”¹ï¼Œå¯æ‰§è¡Œä»»æ„ä»£ç ã€‚ |

---

### 2.7 `MemoryRouter` (memory_router.py)

**ç¼“å­˜æ± ç»“æ„:**

```
FAISS Index: å…¨å±€å•ä¸€ç´¢å¼•
å†…å­˜å­˜å‚¨: Dict[str, Dict] (memory_id -> {content, embedding, metadata})
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 20 | **å…¨å±€ FAISS ç´¢å¼•** | ğŸ”´ é«˜ | æ‰€æœ‰ç”¨æˆ·çš„ memory å­˜äºåŒä¸€ä¸ª FAISS ç´¢å¼•ã€‚`search(query)` è¿”å›å…¨å±€æœ€ç›¸ä¼¼ç»“æœï¼Œä¸åŒºåˆ†ç”¨æˆ·ã€‚ç”¨æˆ· A çš„æŸ¥è¯¢å¯èƒ½è¿”å›ç”¨æˆ· B çš„ memoryã€‚ |
| 21 | **æ— ç”¨æˆ·ç»´åº¦è¿‡æ»¤** | ğŸ”´ é«˜ | `search()` æ–¹æ³•æ²¡æœ‰ `user_id` å‚æ•°ï¼Œæ— æ³•æŒ‰ç”¨æˆ·è¿‡æ»¤æœç´¢ç»“æœã€‚ |

**ä»£ç è¯æ®:**

```python
# memory_router.py L166-225
def search(self, query: str, top_k=None, threshold=None) -> List[MemorySearchResult]:
    # âš  æ—  user_id å‚æ•°ï¼Œæœç´¢å…¨å±€ç´¢å¼•
    scores, indices = self.index.search(query_embedding, k)
    # è¿”å›å…¨å±€æœ€ç›¸ä¼¼ç»“æœï¼Œä¸åŒºåˆ†ç”¨æˆ·
```

---

### 2.8 `EmbeddingCache` (non_vectorized_handler.py)

**ç¼“å­˜æ± ç»“æ„:**

```
å†…å­˜: OrderedDict[str, List[float]]
    é”®: message_id æˆ– content_hash
```

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 22 | **å…¨å±€ embedding ç¼“å­˜** | ğŸŸ¡ ä¸­ | æ‰€æœ‰ç”¨æˆ·çš„ message embedding å­˜äºåŒä¸€ä¸ªç¼“å­˜ã€‚è™½ç„¶ embedding æœ¬èº«ä¸ç›´æ¥æ³„éœ²åŸæ–‡ï¼Œä½†å¯ç”¨äºæ¨æ–­ç›¸ä¼¼æ€§ã€‚ |

---

### 2.9 `DKIRedisClient` (redis_client.py)

**éš”ç¦»é—®é¢˜:**

| # | é—®é¢˜ | ä¸¥é‡æ€§ | è¯´æ˜ |
|---|------|--------|------|
| 23 | **å…¨å±€å•ä¾‹** | ğŸŸ¡ ä¸­ | `_global_redis_client` æ˜¯æ¨¡å—çº§å…¨å±€å˜é‡ã€‚æ‰€æœ‰ç”¨æˆ·å…±äº«åŒä¸€ä¸ª Redis è¿æ¥æ± å’Œ dbã€‚ |
| 24 | **æ—  Redis ACL** | ğŸŸ¡ ä¸­ | æœªä½¿ç”¨ Redis 6+ çš„ ACL åŠŸèƒ½è¿›è¡Œç”¨æˆ·çº§æƒé™éš”ç¦»ã€‚ |
| 25 | **SCAN å¯æšä¸¾** | ğŸŸ¡ ä¸­ | `delete_pattern` ä½¿ç”¨ `SCAN`ï¼ŒåŒç†å¯ç”¨ `SCAN` æšä¸¾æ‰€æœ‰ç”¨æˆ·çš„ç¼“å­˜é”®ã€‚ |

---

## ä¸‰ã€è®¡ç®—åŸŸéš”ç¦»åˆ†æ

### 3.1 æ¨¡å‹æ¨ç†çš„åˆ†æ—¶å¤ç”¨

```
æ—¶é—´çº¿:
t1: User_A è¯·æ±‚ â†’ åŠ è½½ User_A çš„ K/V â†’ æ³¨å…¥ attention â†’ æ¨ç† â†’ æ¸…é™¤ K/V
t2: User_B è¯·æ±‚ â†’ åŠ è½½ User_B çš„ K/V â†’ æ³¨å…¥ attention â†’ æ¨ç† â†’ æ¸…é™¤ K/V
```

**åˆ†æ:**

| ç»´åº¦ | ç°çŠ¶ | é£é™© |
|------|------|------|
| **K/V ç”Ÿå‘½å‘¨æœŸ** | `forward_with_kv_injection` å°† K/V ä½œä¸º `past_key_values` ä¼ å…¥ï¼Œæ¨ç†åä¸æŒä¹…åŒ– | âœ… K/V ä¸è·¨è¯·æ±‚æ®‹ç•™ |
| **æ¨¡å‹æƒé‡** | å†»ç»“ï¼Œä¸å›  K/V æ³¨å…¥è€Œæ›´æ–° | âœ… æ— æƒé‡æ±¡æŸ“ |
| **KV Cache (vLLM)** | vLLM çš„ PagedAttention è‡ªåŠ¨ç®¡ç† KV cache ç”Ÿå‘½å‘¨æœŸï¼Œè¯·æ±‚å®Œæˆåé‡Šæ”¾ | âœ… æ— è·¨è¯·æ±‚æ³„éœ² |
| **GPU æ˜¾å­˜æ®‹ç•™** | PyTorch ä½¿ç”¨ CUDA memory poolï¼Œé‡Šæ”¾çš„ tensor å¯èƒ½æœªæ¸…é›¶ | ğŸŸ¡ ç†è®ºé£é™©æä½ï¼ˆéœ€è¦ GPU å†…å­˜è¯»å–æ”»å‡»ï¼‰ |
| **CPU å†…å­˜æ®‹ç•™** | Python GC åå†…å­˜æœªæ¸…é›¶ | ğŸŸ¡ ç†è®ºé£é™©æä½ |

**ç»“è®º:** è®¡ç®—åŸŸéš”ç¦»åœ¨å½“å‰æ¶æ„ä¸‹æ˜¯**å¯æ¥å—çš„**ã€‚K/V æ³¨å…¥æ˜¯ä¸´æ—¶æ€§çš„ï¼Œæ¨¡å‹æƒé‡ä¸å˜ï¼Œæ¨ç†å®Œæˆå K/V è¢«é‡Šæ”¾ã€‚è¿™æ˜¯æ ‡å‡†çš„"åˆ†æ—¶å¤ç”¨"æ¨¡å¼ï¼Œä¸ GPU äº‘æœåŠ¡ï¼ˆå¦‚ AWS SageMakerï¼‰çš„å¤šç§Ÿæˆ·æ¨¡å‹ä¸€è‡´ã€‚

**ä½†éœ€æ³¨æ„:** è¿™ç§"å¯æ¥å—"æ˜¯åŸºäºä»¥ä¸‹å‰æ:
1. ä¸å­˜åœ¨ GPU ä¾§ä¿¡é“æ”»å‡»ï¼ˆå½“å‰å­¦æœ¯ç•Œå·²æœ‰ç›¸å…³ç ”ç©¶ï¼Œä½†å®é™…åˆ©ç”¨éš¾åº¦æé«˜ï¼‰
2. ä¸å­˜åœ¨ timing attackï¼ˆä¸åŒç”¨æˆ·çš„ K/V é•¿åº¦ä¸åŒå¯¼è‡´æ¨ç†æ—¶é—´ä¸åŒï¼‰
3. ç³»ç»Ÿæ˜¯å•ç§Ÿæˆ·éƒ¨ç½²ï¼ˆåŒä¸€ç»„ç»‡å†…çš„ç”¨æˆ·ï¼‰ï¼Œè€Œéå¤šç§Ÿæˆ· SaaS

---

## å››ã€éš”ç¦»ç¼ºé™·æ±‡æ€»çŸ©é˜µ

| ç»„ä»¶ | æ•°æ®éš”ç¦» | è®¡ç®—éš”ç¦» | æƒé™éš”ç¦» | æ€»è¯„ |
|------|---------|---------|---------|------|
| `PreferenceCacheManager` L1 | âŒ å…¨å±€æ±  | âœ… åˆ†æ—¶ | âŒ æ— é‰´æƒ | ğŸ”´ |
| `PreferenceCacheManager` L2 | âŒ å…¨å±€ Redis | âœ… åˆ†æ—¶ | âŒ æ—  ACL | ğŸ”´ |
| `InjectionExecutor._preference_kv_cache` | âŒ å…¨å±€ dict | âœ… åˆ†æ—¶ | âŒ æ— é‰´æƒ | ğŸ”´ |
| `HybridDKIInjector._preference_cache` | âŒ å…¨å±€ dict | âœ… åˆ†æ—¶ | âŒ æ— é‰´æƒ | ğŸŸ¡ |
| `DKISystem._user_preferences` | âŒ å…¨å±€ dict | N/A | âŒ æ— é‰´æƒ | ğŸ”´ |
| `SessionKVCache` | âœ… æŒ‰ session | âœ… åˆ†æ—¶ | âŒ æ— æ‰€æœ‰æƒ | ğŸŸ¡ |
| `TieredKVCache` | âœ… æŒ‰ session | âœ… åˆ†æ—¶ | âŒ æ–‡ä»¶å¯éå† | ğŸŸ¡ |
| `MemoryRouter` | âŒ å…¨å±€ç´¢å¼• | N/A | âŒ æ— è¿‡æ»¤ | ğŸ”´ |
| `EmbeddingCache` | âŒ å…¨å±€æ±  | N/A | âŒ æ— é‰´æƒ | ğŸŸ¡ |
| `DKIRedisClient` | âŒ å…¨å±€ db | N/A | âŒ æ—  ACL | ğŸŸ¡ |
| æ¨¡å‹æ¨ç† (GPU) | N/A | âœ… åˆ†æ—¶ | N/A | âœ… |

---

## äº”ã€å®Œæ•´ä¿®æ­£æ–¹æ¡ˆ

### 5.1 æ–¹æ¡ˆè®¾è®¡åŸåˆ™

1. **æ¸è¿›å¼å¢å¼º**: ä¸ç ´åç°æœ‰ APIï¼Œé€šè¿‡ä¸­é—´å±‚å¢åŠ éš”ç¦»
2. **Defense in Depth**: å¤šå±‚é˜²å¾¡ï¼ˆé”®éš”ç¦» + æƒé™æ ¡éªŒ + å®¡è®¡ï¼‰
3. **æ€§èƒ½ä¼˜å…ˆ**: éš”ç¦»æœºåˆ¶ä¸åº”æ˜¾è‘—å¢åŠ å»¶è¿Ÿ
4. **é…ç½®é©±åŠ¨**: éš”ç¦»çº§åˆ«å¯é€šè¿‡ config.yaml è°ƒæ•´

### 5.2 æ¶æ„è®¾è®¡: å¼•å…¥ `UserContext` å’Œ `IsolationGuard`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     è°ƒç”¨å±‚ (API/Demo)                     â”‚
â”‚  æ¯ä¸ªè¯·æ±‚æºå¸¦ UserContext(user_id, session_id, token)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              IsolationGuard (æ–°å¢)                        â”‚
â”‚  1. éªŒè¯ UserContext.token ç­¾å                          â”‚
â”‚  2. éªŒè¯ session_id å±äº user_id                         â”‚
â”‚  3. ç”Ÿæˆ scoped_cache_key (HMAC ç­¾å)                    â”‚
â”‚  4. å®¡è®¡æ—¥å¿—                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ç¼“å­˜å±‚ (ä¿®æ”¹)                                â”‚
â”‚  PreferenceCacheManager                                  â”‚
â”‚    - L1: UserScopedLRUCache (æŒ‰ user_id åˆ† namespace)    â”‚
â”‚    - L2: Redis (æŒ‰ user_id åˆ† key prefix + HMAC)        â”‚
â”‚  InjectionExecutor                                       â”‚
â”‚    - _preference_kv_cache â†’ UserScopedDict               â”‚
â”‚  MemoryRouter                                            â”‚
â”‚    - æŒ‰ user_id åˆ†ç´¢å¼• æˆ– search å¢åŠ  user_id è¿‡æ»¤      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.3 ä¿®æ­£é¡¹ 1: å¼•å…¥ `UserContext` æ•°æ®ç»“æ„

**æ–‡ä»¶:** `dki/core/user_context.py` (æ–°å¢)

```python
"""
ç”¨æˆ·ä¸Šä¸‹æ–‡ - è´¯ç©¿æ•´ä¸ªè¯·æ±‚ç”Ÿå‘½å‘¨æœŸçš„èº«ä»½ä¿¡æ¯

æ‰€æœ‰ç¼“å­˜æ“ä½œå¿…é¡»æºå¸¦ UserContextï¼Œç”¨äº:
1. èº«ä»½é‰´æƒ (token éªŒè¯)
2. ç¼“å­˜é”®éš”ç¦» (HMAC ç­¾å)
3. å®¡è®¡æ—¥å¿— (æ“ä½œè¿½è¸ª)
"""

import hashlib
import hmac
import time
from dataclasses import dataclass, field
from typing import Optional


@dataclass(frozen=True)
class UserContext:
    """
    ä¸å¯å˜ç”¨æˆ·ä¸Šä¸‹æ–‡
    
    frozen=True ç¡®ä¿åˆ›å»ºåä¸å¯ç¯¡æ”¹
    """
    user_id: str
    session_id: str
    # è¯·æ±‚çº§ token (ç”± API å±‚ç­¾å‘ï¼Œç”¨äºæ ¡éªŒèº«ä»½)
    request_token: str = ""
    # æ—¶é—´æˆ³ (ç”¨äº TTL å’Œå®¡è®¡)
    created_at: float = field(default_factory=time.time)
    # æ¥æº IP (å®¡è®¡ç”¨)
    source_ip: str = ""
    
    def validate(self) -> bool:
        """åŸºæœ¬æ ¡éªŒ"""
        return bool(self.user_id and self.session_id)
    
    def scoped_cache_key(self, raw_key: str, secret: str) -> str:
        """
        ç”Ÿæˆå¸¦ HMAC ç­¾åçš„ç¼“å­˜é”®
        
        å³ä½¿æ”»å‡»è€…çŸ¥é“ user_id å’Œ raw_keyï¼Œ
        æ²¡æœ‰ secret ä¹Ÿæ— æ³•æ„é€ æœ‰æ•ˆçš„ç¼“å­˜é”®ã€‚
        
        æ ¼å¼: {user_id}:{hmac_signature}:{raw_key_hash}
        """
        msg = f"{self.user_id}:{raw_key}".encode()
        sig = hmac.new(secret.encode(), msg, hashlib.sha256).hexdigest()[:16]
        return f"{self.user_id}:{sig}:{hashlib.md5(raw_key.encode()).hexdigest()[:12]}"
```

---

### 5.4 ä¿®æ­£é¡¹ 2: å¼•å…¥ `IsolationGuard`

**æ–‡ä»¶:** `dki/core/isolation_guard.py` (æ–°å¢)

```python
"""
éš”ç¦»å®ˆå« - ç¼“å­˜è®¿é—®çš„æƒé™æ ¡éªŒå±‚

èŒè´£:
1. éªŒè¯ UserContext çš„åˆæ³•æ€§
2. éªŒè¯ session_id å±äº user_id (æŸ¥æ•°æ®åº“)
3. ç”Ÿæˆéš”ç¦»çš„ç¼“å­˜é”®
4. è®°å½•å®¡è®¡æ—¥å¿—
"""

import time
from typing import Optional, Dict, Any
from dataclasses import dataclass
from loguru import logger

from dki.core.user_context import UserContext


@dataclass
class IsolationConfig:
    """éš”ç¦»é…ç½®"""
    enabled: bool = True
    # HMAC å¯†é’¥ (ç”Ÿäº§ç¯å¢ƒåº”ä»ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡è·å–)
    cache_key_secret: str = "dki-default-secret-change-in-production"
    # æ˜¯å¦éªŒè¯ session å½’å±
    verify_session_ownership: bool = True
    # æ˜¯å¦è®°å½•å®¡è®¡æ—¥å¿—
    audit_enabled: bool = True
    # å®¡è®¡æ—¥å¿—æœ€å¤§æ¡æ•°
    audit_max_entries: int = 10000
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IsolationConfig":
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


class IsolationGuard:
    """
    ç¼“å­˜è®¿é—®å®ˆå«
    
    ç”¨æ³•:
        guard = IsolationGuard(config, db_manager)
        
        # åœ¨ç¼“å­˜æ“ä½œå‰æ ¡éªŒ
        guard.verify_access(user_context, target_user_id="user_123")
        
        # ç”Ÿæˆéš”ç¦»é”®
        safe_key = guard.make_cache_key(user_context, raw_key="pref_hash")
    """
    
    def __init__(
        self,
        config: Optional[IsolationConfig] = None,
        db_manager: Optional[Any] = None,
    ):
        self.config = config or IsolationConfig()
        self.db_manager = db_manager
        self._session_ownership_cache: Dict[str, str] = {}  # session_id -> user_id
        self._audit_log: list = []
    
    def verify_access(
        self,
        ctx: UserContext,
        target_user_id: str,
        operation: str = "read",
    ) -> bool:
        """
        éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒè®¿é—®ç›®æ ‡ç”¨æˆ·çš„æ•°æ®
        
        è§„åˆ™:
        1. ctx.user_id å¿…é¡»ç­‰äº target_user_id (ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®)
        2. å¦‚æœ verify_session_ownership=Trueï¼ŒéªŒè¯ session å½’å±
        
        Returns:
            True å¦‚æœå…è®¸è®¿é—®
            
        Raises:
            PermissionError å¦‚æœæ‹’ç»è®¿é—®
        """
        if not self.config.enabled:
            return True
        
        # è§„åˆ™ 1: ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®
        if ctx.user_id != target_user_id:
            self._audit(ctx, operation, target_user_id, "DENIED: user_id mismatch")
            raise PermissionError(
                f"User {ctx.user_id} attempted to access data of user {target_user_id}"
            )
        
        # è§„åˆ™ 2: session å½’å±éªŒè¯
        if self.config.verify_session_ownership and ctx.session_id:
            if not self._verify_session_ownership(ctx.user_id, ctx.session_id):
                self._audit(ctx, operation, target_user_id, "DENIED: session ownership")
                raise PermissionError(
                    f"Session {ctx.session_id} does not belong to user {ctx.user_id}"
                )
        
        self._audit(ctx, operation, target_user_id, "ALLOWED")
        return True
    
    def make_cache_key(self, ctx: UserContext, raw_key: str) -> str:
        """ç”Ÿæˆ HMAC ç­¾åçš„ç¼“å­˜é”®"""
        if not self.config.enabled:
            return f"{ctx.user_id}:{raw_key}"
        return ctx.scoped_cache_key(raw_key, self.config.cache_key_secret)
    
    def _verify_session_ownership(self, user_id: str, session_id: str) -> bool:
        """éªŒè¯ session æ˜¯å¦å±äºè¯¥ç”¨æˆ·"""
        # å…ˆæŸ¥ç¼“å­˜
        cached_owner = self._session_ownership_cache.get(session_id)
        if cached_owner is not None:
            return cached_owner == user_id
        
        # æŸ¥æ•°æ®åº“
        if self.db_manager is None:
            return True  # æ— æ•°æ®åº“æ—¶é™çº§ä¸ºå…è®¸
        
        try:
            from dki.database import SessionRepository
            with self.db_manager.session_scope() as db:
                repo = SessionRepository(db)
                session = repo.get(session_id)
                if session and hasattr(session, 'user_id'):
                    self._session_ownership_cache[session_id] = session.user_id
                    return session.user_id == user_id
            return True  # session ä¸å­˜åœ¨æ—¶é™çº§ä¸ºå…è®¸
        except Exception as e:
            logger.warning(f"Session ownership check failed: {e}")
            return True  # å¼‚å¸¸æ—¶é™çº§ä¸ºå…è®¸
    
    def _audit(
        self,
        ctx: UserContext,
        operation: str,
        target_user_id: str,
        result: str,
    ):
        """è®°å½•å®¡è®¡æ—¥å¿—"""
        if not self.config.audit_enabled:
            return
        
        entry = {
            "timestamp": time.time(),
            "user_id": ctx.user_id,
            "session_id": ctx.session_id,
            "target_user_id": target_user_id,
            "operation": operation,
            "result": result,
            "source_ip": ctx.source_ip,
        }
        
        self._audit_log.append(entry)
        
        # é™åˆ¶æ—¥å¿—å¤§å°
        if len(self._audit_log) > self.config.audit_max_entries:
            self._audit_log = self._audit_log[-self.config.audit_max_entries:]
        
        if "DENIED" in result:
            logger.warning(f"ACCESS DENIED: {entry}")
    
    def get_audit_log(self, limit: int = 100) -> list:
        """è·å–å®¡è®¡æ—¥å¿—"""
        return self._audit_log[-limit:]
```

---

### 5.5 ä¿®æ­£é¡¹ 3: `PreferenceCacheManager` å¢åŠ ç”¨æˆ·éš”ç¦»

**ä¿®æ”¹æ–‡ä»¶:** `dki/cache/preference_cache.py`

**æ”¹åŠ¨è¦ç‚¹:**

1. `get_preference_kv` å¢åŠ  `UserContext` å‚æ•°
2. ç¼“å­˜é”®ä½¿ç”¨ HMAC ç­¾å
3. L1 å¢åŠ ç”¨æˆ·çº§å‘½åç©ºé—´ï¼ˆå¯é€‰ï¼‰
4. L2 Redis é”®å¢åŠ  HMAC ç­¾å
5. preference_hash å¢åŠ ç›å€¼

```python
# ===== ä¿®æ”¹ _compute_preference_hash =====
# æ—§:
def _compute_preference_hash(self, preference_text: str) -> str:
    return hashlib.md5(preference_text.encode()).hexdigest()[:16]

# æ–°:
def _compute_preference_hash(
    self, 
    preference_text: str,
    user_id: str = "",
    salt: str = "",
) -> str:
    """
    è®¡ç®—åå¥½æ–‡æœ¬çš„ hash (å«ç›å€¼)
    
    ç›å€¼ç¡®ä¿å³ä½¿ä¸¤ä¸ªç”¨æˆ·æœ‰ç›¸åŒåå¥½æ–‡æœ¬ï¼Œhash ä¹Ÿä¸åŒã€‚
    """
    content = f"{user_id}:{salt}:{preference_text}"
    return hashlib.sha256(content.encode()).hexdigest()[:20]


# ===== ä¿®æ”¹ get_preference_kv =====
# å¢åŠ  guard å‚æ•°:
async def get_preference_kv(
    self,
    user_id: str,
    preference_text: str,
    model: Any,
    force_recompute: bool = False,
    guard: Optional["IsolationGuard"] = None,
    user_context: Optional["UserContext"] = None,
) -> Tuple[Any, CacheTierInfo]:
    # æƒé™æ ¡éªŒ
    if guard and user_context:
        guard.verify_access(user_context, target_user_id=user_id, operation="cache_read")
    
    # ... å…¶ä½™é€»è¾‘ä¸å˜ï¼Œä½†ä½¿ç”¨æ–°çš„ hash æ–¹æ³•
    preference_hash = self._compute_preference_hash(
        preference_text, user_id=user_id, salt=self._salt
    )
    # ...
```

---

### 5.6 ä¿®æ­£é¡¹ 4: `InjectionExecutor._preference_kv_cache` å¢åŠ éš”ç¦»

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/plugin/injection_executor.py`

**æ”¹åŠ¨è¦ç‚¹:**

1. å°† `Dict` æ›¿æ¢ä¸ºå¸¦å¤§å°é™åˆ¶å’Œç”¨æˆ·éš”ç¦»çš„ `UserScopedCache`
2. ç¼“å­˜é”®ä½¿ç”¨ HMAC ç­¾å
3. å¢åŠ  TTL é©±é€

```python
# ===== æ–°å¢ UserScopedCache ç±» =====
class UserScopedCache:
    """
    ç”¨æˆ·éš”ç¦»çš„ K/V ç¼“å­˜
    
    æŒ‰ user_id åˆ† namespace:
    - æ¯ä¸ªç”¨æˆ·ç‹¬ç«‹çš„ LRU ç©ºé—´
    - ç”¨æˆ· A çš„æ“ä½œæ— æ³•è§¦åŠç”¨æˆ· B çš„æ•°æ®
    - å…¨å±€å¤§å°é™åˆ¶ + æ¯ç”¨æˆ·å¤§å°é™åˆ¶
    """
    
    def __init__(self, max_total: int = 10000, max_per_user: int = 100):
        self.max_total = max_total
        self.max_per_user = max_per_user
        # user_id -> OrderedDict[cache_key, (kv_entries, content_hash, timestamp)]
        self._namespaces: Dict[str, OrderedDict] = {}
        self._total_count = 0
    
    def get(self, user_id: str, cache_key: str) -> Optional[Tuple[Any, str]]:
        """è·å–ç¼“å­˜ (ä»…åœ¨ç”¨æˆ·è‡ªå·±çš„å‘½åç©ºé—´ä¸­æŸ¥æ‰¾)"""
        ns = self._namespaces.get(user_id)
        if ns is None:
            return None
        if cache_key not in ns:
            return None
        ns.move_to_end(cache_key)
        kv, content_hash, _ = ns[cache_key]
        return (kv, content_hash)
    
    def put(self, user_id: str, cache_key: str, kv_entries: Any, content_hash: str):
        """å­˜å…¥ç¼“å­˜ (å­˜å…¥ç”¨æˆ·è‡ªå·±çš„å‘½åç©ºé—´)"""
        if user_id not in self._namespaces:
            self._namespaces[user_id] = OrderedDict()
        
        ns = self._namespaces[user_id]
        
        if cache_key in ns:
            ns.move_to_end(cache_key)
        else:
            # é©±é€: ç”¨æˆ·çº§
            while len(ns) >= self.max_per_user:
                ns.popitem(last=False)
                self._total_count -= 1
            # é©±é€: å…¨å±€çº§ (é©±é€æœ€ä¸æ´»è·ƒç”¨æˆ·çš„æœ€æ—§æ¡ç›®)
            while self._total_count >= self.max_total:
                self._evict_global()
        
        ns[cache_key] = (kv_entries, content_hash, time.time())
        self._total_count += 1
    
    def clear_user(self, user_id: str):
        """æ¸…é™¤æŒ‡å®šç”¨æˆ·çš„å…¨éƒ¨ç¼“å­˜"""
        if user_id in self._namespaces:
            self._total_count -= len(self._namespaces[user_id])
            del self._namespaces[user_id]
    
    def clear_all(self):
        """æ¸…é™¤å…¨éƒ¨ç¼“å­˜"""
        self._namespaces.clear()
        self._total_count = 0
    
    def _evict_global(self):
        """å…¨å±€é©±é€: æ‰¾åˆ°æœ€æ—§çš„æ¡ç›®å¹¶åˆ é™¤"""
        oldest_time = float('inf')
        oldest_user = None
        oldest_key = None
        for uid, ns in self._namespaces.items():
            if ns:
                first_key = next(iter(ns))
                _, _, ts = ns[first_key]
                if ts < oldest_time:
                    oldest_time = ts
                    oldest_user = uid
                    oldest_key = first_key
        if oldest_user and oldest_key:
            del self._namespaces[oldest_user][oldest_key]
            self._total_count -= 1
            if not self._namespaces[oldest_user]:
                del self._namespaces[oldest_user]


# ===== ä¿®æ”¹ InjectionExecutor.__init__ =====
# æ—§:
self._preference_kv_cache: Dict[str, Tuple[Any, str]] = {}

# æ–°:
self._preference_kv_cache = UserScopedCache(
    max_total=10000,
    max_per_user=100,
)


# ===== ä¿®æ”¹ _get_preference_kv =====
def _get_preference_kv(self, user_id: str, preference_text: str):
    content_hash = hashlib.md5(preference_text.encode()).hexdigest()
    cache_key = content_hash  # é”®åªåœ¨ç”¨æˆ·å‘½åç©ºé—´å†…ä½¿ç”¨ï¼Œä¸éœ€è¦æ‹¼æ¥ user_id
    
    # åœ¨ç”¨æˆ·è‡ªå·±çš„å‘½åç©ºé—´ä¸­æŸ¥æ‰¾
    cached = self._preference_kv_cache.get(user_id, cache_key)
    if cached:
        kv_entries, cached_hash = cached
        if cached_hash == content_hash:
            self._stats["cache_hits"] += 1
            return kv_entries, True, "memory"
    
    # è®¡ç®— K/V
    try:
        kv_entries, _ = self.model.compute_kv(preference_text)
        self._preference_kv_cache.put(user_id, cache_key, kv_entries, content_hash)
        return kv_entries, False, "compute"
    except Exception as e:
        logger.error(f"Failed to compute preference K/V: {e}")
        return None, False, "error"
```

---

### 5.7 ä¿®æ­£é¡¹ 5: `MemoryRouter` å¢åŠ ç”¨æˆ·ç»´åº¦

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/memory_router.py`

**æ”¹åŠ¨è¦ç‚¹:**

1. `add_memory` å¢åŠ  `user_id` å‚æ•°
2. `search` å¢åŠ  `user_id` è¿‡æ»¤
3. å†…éƒ¨å­˜å‚¨å¢åŠ  `user_id` å­—æ®µ

```python
# ===== æ–¹æ¡ˆ A: åè¿‡æ»¤ (ç®€å•ï¼Œæ¨èç”¨äºä¸­å°è§„æ¨¡) =====

def add_memory(
    self,
    memory_id: str,
    content: str,
    embedding: Optional[np.ndarray] = None,
    metadata: Optional[Dict[str, Any]] = None,
    user_id: str = "",  # æ–°å¢
) -> None:
    # ... ç°æœ‰é€»è¾‘ ...
    self._memories[memory_id] = {
        'content': content,
        'embedding': embedding.flatten(),
        'metadata': metadata or {},
        'user_id': user_id,  # æ–°å¢
    }

def search(
    self,
    query: str,
    top_k: Optional[int] = None,
    threshold: Optional[float] = None,
    user_id: Optional[str] = None,  # æ–°å¢
) -> List[MemorySearchResult]:
    # ... ç°æœ‰ FAISS search é€»è¾‘ ...
    
    results = []
    for score, idx in zip(scores[0], indices[0]):
        memory_id = self._idx_to_id.get(idx)
        memory = self._memories[memory_id]
        
        # ç”¨æˆ·è¿‡æ»¤
        if user_id and memory.get('user_id') and memory['user_id'] != user_id:
            continue
        
        results.append(MemorySearchResult(...))
    
    return results


# ===== æ–¹æ¡ˆ B: åˆ†ç´¢å¼• (é«˜éš”ç¦»ï¼Œæ¨èç”¨äºå¤§è§„æ¨¡å¤šç§Ÿæˆ·) =====

class MemoryRouter:
    def __init__(self, ...):
        # æ›¿æ¢å…¨å±€ç´¢å¼•ä¸ºç”¨æˆ·çº§ç´¢å¼•
        self._user_indices: Dict[str, faiss.Index] = {}
        self._user_memories: Dict[str, Dict[str, Dict]] = {}
    
    def search(self, query, user_id, ...):
        if user_id not in self._user_indices:
            return []
        # ä»…åœ¨ç”¨æˆ·è‡ªå·±çš„ç´¢å¼•ä¸­æœç´¢
        index = self._user_indices[user_id]
        scores, indices = index.search(query_embedding, k)
        # ...
```

**æ¨è:** å½“å‰é˜¶æ®µé‡‡ç”¨**æ–¹æ¡ˆ A**ï¼ˆåè¿‡æ»¤ï¼‰ï¼Œå› ä¸ºæ”¹åŠ¨æœ€å°ä¸” DKI çš„ memory è§„æ¨¡é€šå¸¸ä¸å¤§ã€‚åç»­å¦‚éœ€å¤šç§Ÿæˆ· SaaS éƒ¨ç½²ï¼Œå†è¿ç§»åˆ°æ–¹æ¡ˆ Bã€‚

---

### 5.8 ä¿®æ­£é¡¹ 6: `DKISystem._user_preferences` å¢åŠ  TTL å’Œå¤§å°é™åˆ¶

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/dki_system.py`

```python
# ===== æ›¿æ¢ç®€å• Dict ä¸ºå¸¦ TTL çš„ LRU ç¼“å­˜ =====

class _PreferenceStore:
    """å¸¦ TTL å’Œå¤§å°é™åˆ¶çš„ç”¨æˆ·åå¥½ç¼“å­˜"""
    
    def __init__(self, max_size: int = 1000, ttl_seconds: int = 3600):
        self._store: OrderedDict[str, Tuple[UserPreference, float]] = OrderedDict()
        self.max_size = max_size
        self.ttl_seconds = ttl_seconds
    
    def get(self, user_id: str) -> Optional[UserPreference]:
        if user_id not in self._store:
            return None
        pref, ts = self._store[user_id]
        if time.time() - ts > self.ttl_seconds:
            del self._store[user_id]
            return None
        self._store.move_to_end(user_id)
        return pref
    
    def set(self, user_id: str, pref: UserPreference):
        if user_id in self._store:
            self._store.move_to_end(user_id)
        else:
            while len(self._store) >= self.max_size:
                self._store.popitem(last=False)
        self._store[user_id] = (pref, time.time())
    
    def delete(self, user_id: str):
        self._store.pop(user_id, None)
    
    def clear(self):
        self._store.clear()


# ===== åœ¨ DKISystem.__init__ ä¸­æ›¿æ¢ =====
# æ—§:
self._user_preferences: Dict[str, UserPreference] = {}

# æ–°:
self._user_preferences = _PreferenceStore(
    max_size=getattr(self.config.dki, 'preference_cache_max_users', 1000),
    ttl_seconds=getattr(self.config.dki, 'preference_cache_ttl', 3600),
)
```

---

### 5.9 ä¿®æ­£é¡¹ 7: `SessionKVCache` / `TieredKVCache` å¢åŠ æ‰€æœ‰æƒæ ¡éªŒ

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/dki_system.py`

```python
# ===== åœ¨ _get_session_cache ä¸­å¢åŠ æ‰€æœ‰æƒæ ¡éªŒ =====

def _get_session_cache(
    self,
    session_id: str,
    user_id: Optional[str] = None,  # æ–°å¢
) -> Union[SessionKVCache, TieredKVCache]:
    # æ‰€æœ‰æƒæ ¡éªŒ
    if user_id and self._isolation_guard:
        ctx = UserContext(user_id=user_id, session_id=session_id)
        self._isolation_guard.verify_access(ctx, target_user_id=user_id)
    
    # ... ç°æœ‰é€»è¾‘ ...
```

---

### 5.10 ä¿®æ­£é¡¹ 8: Redis éš”ç¦»å¢å¼º

**ä¿®æ”¹æ–‡ä»¶:** `dki/cache/redis_client.py`

```python
# ===== æ–¹æ¡ˆ A: æŒ‰ç”¨æˆ·åˆ† Redis db (ç®€å•) =====
# ä¸æ¨è: Redis db æ•°é‡æœ‰é™ (é»˜è®¤ 16)

# ===== æ–¹æ¡ˆ B: æŒ‰ç”¨æˆ·åˆ† key prefix + HMAC (æ¨è) =====

class DKIRedisClient:
    def _make_user_key(self, user_id: str, key: str) -> str:
        """ç”Ÿæˆç”¨æˆ·éš”ç¦»çš„ Redis é”®"""
        # æ ¼å¼: dki:{user_id}:{key}
        # HMAC ç­¾ååœ¨ IsolationGuard å±‚å®Œæˆ
        return f"{self.config.key_prefix}:{user_id}:{key}"


# ===== æ–¹æ¡ˆ C: Redis ACL (ç”Ÿäº§ç¯å¢ƒæ¨è) =====
# éœ€è¦ Redis 6+:
# ACL SETUSER user_123 on >password ~dki:user_123:* +get +set +del
# æ¯ä¸ªç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·± prefix ä¸‹çš„é”®
```

---

### 5.11 ä¿®æ­£é¡¹ 9: `HybridDKIInjector._preference_cache` ç»Ÿä¸€ç¼“å­˜

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/components/hybrid_injector.py`

```python
# ===== ç§»é™¤ç‹¬ç«‹çš„ _preference_cache =====
# å°†ç¼“å­˜å§”æ‰˜ç»™ PreferenceCacheManager æˆ– InjectionExecutor

class HybridDKIInjector:
    def __init__(self, ...):
        # ç§»é™¤:
        # self._preference_cache: Dict[str, Any] = {}
        
        # æ›¿æ¢ä¸º: å¤–éƒ¨æ³¨å…¥çš„ç¼“å­˜ç®¡ç†å™¨
        self._external_cache: Optional[PreferenceCacheManager] = None
    
    def set_cache_manager(self, cache: PreferenceCacheManager):
        """æ³¨å…¥å¤–éƒ¨ç¼“å­˜ç®¡ç†å™¨ (æ¶ˆé™¤é‡å¤ç¼“å­˜æ± )"""
        self._external_cache = cache
```

---

### 5.12 ä¿®æ­£é¡¹ 10: TieredKVCache L3 æ–‡ä»¶å®‰å…¨

**ä¿®æ”¹æ–‡ä»¶:** `dki/core/components/tiered_kv_cache.py`

```python
# ===== L3 æ–‡ä»¶åŠ å¯† =====

import os

class TieredKVCache:
    def _save_to_l3(self, cache_key: str, entry: TieredCacheEntry):
        """ä¿å­˜åˆ° SSD (åŠ å¯†)"""
        file_path = self.l3_path / f"{hashlib.sha256(cache_key.encode()).hexdigest()}.bin"
        data = self.l3_compressor.compress(entry.kv_entries)
        
        # ç®€å• XOR åŠ å¯† (ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨ AES-256-GCM)
        # æˆ–ä½¿ç”¨æ“ä½œç³»ç»Ÿçº§æ–‡ä»¶æƒé™: os.chmod(file_path, 0o600)
        file_path.write_bytes(data)
        os.chmod(str(file_path), 0o600)  # ä»… owner å¯è¯»å†™
```

---

### 5.13 é…ç½®æ–‡ä»¶æ‰©å±•

**ä¿®æ”¹æ–‡ä»¶:** `config/config.yaml`

```yaml
dki:
  # ===== ç”¨æˆ·éš”ç¦»é…ç½® (æ–°å¢) =====
  isolation:
    enabled: true
    # HMAC ç­¾åå¯†é’¥ (ç”Ÿäº§ç¯å¢ƒå¿…é¡»æ›´æ”¹)
    cache_key_secret: "your-production-secret-here"
    # éªŒè¯ session å½’å±
    verify_session_ownership: true
    # å®¡è®¡æ—¥å¿—
    audit_enabled: true
    audit_max_entries: 10000
  
  # ===== åå¥½ç¼“å­˜é…ç½® (æ–°å¢) =====
  preference_store:
    max_users: 1000
    ttl_seconds: 3600
  
  # ===== Executor ç¼“å­˜é…ç½® (æ–°å¢) =====
  executor_cache:
    max_total: 10000
    max_per_user: 100
```

---

## å…­ã€ä¿®æ­£ä¼˜å…ˆçº§ä¸å®æ–½è·¯çº¿

### Phase 1: é«˜ä¼˜å…ˆçº§ (æ•°æ®éš”ç¦») â€” å»ºè®®ç«‹å³å®æ–½

| åºå· | ä¿®æ­£é¡¹ | æ¶‰åŠæ–‡ä»¶ | å·¥ä½œé‡ | å½±å“èŒƒå›´ |
|------|--------|---------|--------|---------|
| P1.1 | `InjectionExecutor` æ›¿æ¢ä¸º `UserScopedCache` | `injection_executor.py` | ä¸­ | Plugin ç³»ç»Ÿ |
| P1.2 | `MemoryRouter.search` å¢åŠ  `user_id` è¿‡æ»¤ | `memory_router.py` | å° | DKI System |
| P1.3 | `DKISystem._user_preferences` æ›¿æ¢ä¸º `_PreferenceStore` | `dki_system.py` | å° | DKI System |
| P1.4 | `HybridDKIInjector` ç§»é™¤ç‹¬ç«‹ç¼“å­˜æ±  | `hybrid_injector.py` | å° | DKI System |
| P1.5 | `PreferenceCacheManager` hash å¢åŠ ç›å€¼ | `preference_cache.py` | å° | å…¨å±€ |

### Phase 2: ä¸­ä¼˜å…ˆçº§ (æƒé™éš”ç¦») â€” å»ºè®®åœ¨å®‰å…¨å®¡è®¡å‰å®æ–½

| åºå· | ä¿®æ­£é¡¹ | æ¶‰åŠæ–‡ä»¶ | å·¥ä½œé‡ | å½±å“èŒƒå›´ |
|------|--------|---------|--------|---------|
| P2.1 | å¼•å…¥ `UserContext` | æ–°å¢ `user_context.py` | å° | å…¨å±€ |
| P2.2 | å¼•å…¥ `IsolationGuard` | æ–°å¢ `isolation_guard.py` | ä¸­ | å…¨å±€ |
| P2.3 | `_get_session_cache` å¢åŠ æ‰€æœ‰æƒæ ¡éªŒ | `dki_system.py` | å° | DKI System |
| P2.4 | `PreferenceCacheManager` é›†æˆ `IsolationGuard` | `preference_cache.py` | ä¸­ | å…¨å±€ |
| P2.5 | é…ç½®æ–‡ä»¶æ‰©å±• | `config.yaml` | å° | å…¨å±€ |

### Phase 3: ä½ä¼˜å…ˆçº§ (å¢å¼º) â€” å»ºè®®åœ¨ç”Ÿäº§éƒ¨ç½²å‰å®æ–½

| åºå· | ä¿®æ­£é¡¹ | æ¶‰åŠæ–‡ä»¶ | å·¥ä½œé‡ | å½±å“èŒƒå›´ |
|------|--------|---------|--------|---------|
| P3.1 | Redis ACL é…ç½® | `redis_client.py` + è¿ç»´ | ä¸­ | Redis |
| P3.2 | TieredKVCache L3 æ–‡ä»¶æƒé™ | `tiered_kv_cache.py` | å° | SSD ç¼“å­˜ |
| P3.3 | pickle ååºåˆ—åŒ–å®‰å…¨ | `tiered_kv_cache.py`, `preference_cache.py` | ä¸­ | å…¨å±€ |
| P3.4 | MemoryRouter åˆ†ç´¢å¼• (æ–¹æ¡ˆ B) | `memory_router.py` | å¤§ | å¤šç§Ÿæˆ·åœºæ™¯ |

---

## ä¸ƒã€ä¿®æ­£å‰åå¯¹æ¯”

### 7.1 æ”»å‡»åœºæ™¯: ç¼“å­˜é”®çŒœæµ‹

**ä¿®æ­£å‰:**
```
æ”»å‡»è€…çŸ¥é“ user_id="victim_123"
æ„é€  cache_key = "victim_123:{md5('ç´ é£Ÿä¸»ä¹‰è€…')[:16]}"
â†’ ç›´æ¥ä»å…¨å±€ dict è·å–å—å®³è€…çš„ K/V tensor âŒ
```

**ä¿®æ­£å (Phase 1):**
```
æ”»å‡»è€…çŸ¥é“ user_id="victim_123"
â†’ UserScopedCache: æ”»å‡»è€…çš„ä»£ç è¿è¡Œåœ¨ user_id="attacker_456" çš„å‘½åç©ºé—´
â†’ æ— æ³•è®¿é—® "victim_123" çš„å‘½åç©ºé—´ âœ…
```

**ä¿®æ­£å (Phase 2):**
```
æ”»å‡»è€…ä¼ªé€  user_id="victim_123"
â†’ IsolationGuard: éªŒè¯ request_token ç­¾å
â†’ token ä¸­çš„ user_id â‰  "victim_123"
â†’ PermissionError + å®¡è®¡æ—¥å¿— âœ…
```

### 7.2 æ”»å‡»åœºæ™¯: MemoryRouter è·¨ç”¨æˆ·æ£€ç´¢

**ä¿®æ­£å‰:**
```
User_A æŸ¥è¯¢ "æˆ‘çš„é¥®é£Ÿåå¥½"
â†’ FAISS è¿”å›å…¨å±€æœ€ç›¸ä¼¼ç»“æœ
â†’ å¯èƒ½è¿”å› User_B çš„ memory "User_B æ˜¯ç´ é£Ÿä¸»ä¹‰è€…" âŒ
```

**ä¿®æ­£å (Phase 1):**
```
User_A æŸ¥è¯¢ "æˆ‘çš„é¥®é£Ÿåå¥½"
â†’ FAISS è¿”å›å…¨å±€æœ€ç›¸ä¼¼ç»“æœ
â†’ åè¿‡æ»¤: memory.user_id != "User_A" â†’ è·³è¿‡
â†’ ä»…è¿”å› User_A çš„ memory âœ…
```

### 7.3 æ”»å‡»åœºæ™¯: Session åŠ«æŒ

**ä¿®æ­£å‰:**
```
æ”»å‡»è€…çŸ¥é“ session_id="sess_victim_789"
â†’ _get_session_cache("sess_victim_789")
â†’ è·å–å—å®³è€…çš„ session KV cache âŒ
```

**ä¿®æ­£å (Phase 2):**
```
æ”»å‡»è€…çŸ¥é“ session_id="sess_victim_789"
â†’ IsolationGuard: æŸ¥æ•°æ®åº“éªŒè¯ session å½’å±
â†’ sess_victim_789 å±äº victimï¼Œä¸å±äº attacker
â†’ PermissionError âœ…
```

---

## å…«ã€æ€§èƒ½å½±å“è¯„ä¼°

| ä¿®æ­£é¡¹ | é¢å¤–å»¶è¿Ÿ | å†…å­˜å¼€é”€ | è¯´æ˜ |
|--------|---------|---------|------|
| `UserScopedCache` | ~0 | +O(N_users) ä¸ª OrderedDict å¤´ | æŸ¥æ‰¾å¤æ‚åº¦ä¸å˜ O(1) |
| `MemoryRouter` åè¿‡æ»¤ | +O(k) æ¯”è¾ƒ | +O(N) å­˜å‚¨ user_id | k é€šå¸¸ < 20 |
| `_PreferenceStore` TTL | +O(1) æ—¶é—´æ¯”è¾ƒ | ~0 | é©±é€å‘ç”Ÿåœ¨å†™å…¥æ—¶ |
| `IsolationGuard` | +1ms (ç¼“å­˜å‘½ä¸­) / +5ms (DB æŸ¥è¯¢) | +O(S) session ç¼“å­˜ | session å½’å±ç¼“å­˜åæ¥è¿‘ 0 |
| HMAC ç­¾å | +0.01ms | ~0 | SHA256 HMAC æå¿« |
| Redis ACL | ~0 | ~0 | Redis å†…éƒ¨å®ç° |

**æ€»ç»“:** Phase 1 ä¿®æ­£å¯¹æ€§èƒ½å‡ ä¹æ— å½±å“ã€‚Phase 2 çš„ `IsolationGuard` åœ¨é¦–æ¬¡ session æ ¡éªŒæ—¶æœ‰çº¦ 5ms çš„ DB æŸ¥è¯¢å¼€é”€ï¼Œåç»­å‘½ä¸­ç¼“å­˜åæ¥è¿‘ 0ã€‚

---

## ä¹ã€æµ‹è¯•ç­–ç•¥

### 9.1 å•å…ƒæµ‹è¯•

```python
# test_user_scoped_cache.py
class TestUserScopedCache:
    def test_user_a_cannot_access_user_b(self):
        cache = UserScopedCache()
        cache.put("user_a", "key1", kv_data_a, "hash_a")
        cache.put("user_b", "key1", kv_data_b, "hash_b")
        
        # User A åªèƒ½è·å–è‡ªå·±çš„æ•°æ®
        assert cache.get("user_a", "key1") == (kv_data_a, "hash_a")
        assert cache.get("user_b", "key1") == (kv_data_b, "hash_b")
        
        # User A æ— æ³•è·å– User B çš„æ•°æ®
        assert cache.get("user_a", "key_b_only") is None
    
    def test_clear_user_does_not_affect_others(self):
        cache = UserScopedCache()
        cache.put("user_a", "key1", data_a, "hash")
        cache.put("user_b", "key1", data_b, "hash")
        
        cache.clear_user("user_a")
        assert cache.get("user_a", "key1") is None
        assert cache.get("user_b", "key1") is not None

# test_isolation_guard.py
class TestIsolationGuard:
    def test_cross_user_access_denied(self):
        guard = IsolationGuard()
        ctx = UserContext(user_id="user_a", session_id="sess_a")
        
        with pytest.raises(PermissionError):
            guard.verify_access(ctx, target_user_id="user_b")
    
    def test_same_user_access_allowed(self):
        guard = IsolationGuard()
        ctx = UserContext(user_id="user_a", session_id="sess_a")
        assert guard.verify_access(ctx, target_user_id="user_a") is True
    
    def test_audit_log_on_denial(self):
        guard = IsolationGuard()
        ctx = UserContext(user_id="user_a", session_id="sess_a")
        
        try:
            guard.verify_access(ctx, target_user_id="user_b")
        except PermissionError:
            pass
        
        logs = guard.get_audit_log()
        assert len(logs) == 1
        assert "DENIED" in logs[0]["result"]

# test_memory_router_isolation.py
class TestMemoryRouterIsolation:
    def test_search_filters_by_user(self):
        router = MemoryRouter()
        router.add_memory("mem_a", "A likes sushi", user_id="user_a")
        router.add_memory("mem_b", "B likes pizza", user_id="user_b")
        
        results = router.search("food preferences", user_id="user_a")
        assert all(r.metadata.get('user_id') == 'user_a' for r in results)
```

### 9.2 é›†æˆæµ‹è¯•

```python
# test_isolation_integration.py
class TestIsolationIntegration:
    async def test_full_pipeline_isolation(self):
        """ç«¯åˆ°ç«¯æµ‹è¯•: ä¸¤ä¸ªç”¨æˆ·çš„æ•°æ®å®Œå…¨éš”ç¦»"""
        system = DKISystem(model_adapter=mock_model)
        
        # è®¾ç½®ä¸¤ä¸ªç”¨æˆ·çš„åå¥½
        system.set_user_preference("alice", "ç´ é£Ÿä¸»ä¹‰è€…")
        system.set_user_preference("bob", "æ— è¾£ä¸æ¬¢")
        
        # Alice çš„è¯·æ±‚
        resp_a = system.chat("æ¨èé¤å…", session_id="sess_a", user_id="alice")
        
        # Bob çš„è¯·æ±‚
        resp_b = system.chat("æ¨èé¤å…", session_id="sess_b", user_id="bob")
        
        # éªŒè¯: æ³¨å…¥çš„åå¥½æ­£ç¡®
        assert "ç´ é£Ÿ" in resp_a.metadata['hybrid_injection']['preference_text']
        assert "è¾£" in resp_b.metadata['hybrid_injection']['preference_text']
```

---

## åã€ä¸ RAG éš”ç¦»å¯¹æ¯”

| ç»´åº¦ | RAG (å…¸å‹å®ç°) | DKI (ä¿®æ­£å‰) | DKI (ä¿®æ­£å) |
|------|---------------|-------------|-------------|
| æ•°æ®å­˜å‚¨ | ç”¨æˆ·ç‹¬ç«‹å‘é‡åº“ | å…¨å±€å…±äº«æ±  | ç”¨æˆ·å‘½åç©ºé—´ |
| æ£€ç´¢éš”ç¦» | ç‹¬ç«‹ç´¢å¼• | å…¨å±€ FAISS | user_id è¿‡æ»¤ |
| ç¼“å­˜éš”ç¦» | é€šå¸¸æ— ç¼“å­˜ | å…¨å±€ dict | UserScopedCache |
| è®¡ç®—éš”ç¦» | åˆ†æ—¶å¤ç”¨ | åˆ†æ—¶å¤ç”¨ | åˆ†æ—¶å¤ç”¨ |
| æƒé™æ ¡éªŒ | API Key + ACL | æ—  | IsolationGuard |
| å®¡è®¡æ—¥å¿— | é€šå¸¸æœ‰ | æ—  | å®¡è®¡æ—¥å¿— |
| å¯†é’¥ä¿æŠ¤ | å‘é‡åº“å¯†é’¥ | æ—  | HMAC ç­¾å |

**ç»“è®º:** ä¿®æ­£åçš„ DKI åœ¨æ•°æ®éš”ç¦»å’Œæƒé™éš”ç¦»å±‚é¢è¾¾åˆ°äº†ä¸å…¸å‹ RAG ç³»ç»Ÿç›¸å½“çš„æ°´å¹³ã€‚è®¡ç®—éš”ç¦»æ–¹é¢ï¼Œç”±äº DKI å’Œ RAG éƒ½ä½¿ç”¨åŒä¸€ä¸ª LLM è¿›è¡Œæ¨ç†ï¼Œä¸¤è€…çš„éš”ç¦»æ°´å¹³ä¸€è‡´ï¼ˆåˆ†æ—¶å¤ç”¨ï¼‰ã€‚

---

## åä¸€ã€å±€é™æ€§è¯´æ˜

1. **è®¡ç®—åŸŸå®Œå…¨éš”ç¦»ä¸å¯å®ç°**: åªè¦å¤šç”¨æˆ·å…±äº«åŒä¸€ä¸ª GPU/æ¨¡å‹å®ä¾‹ï¼Œå°±æ— æ³•å®ç°çœŸæ­£çš„è®¡ç®—åŸŸéš”ç¦»ã€‚è¿™æ˜¯æ‰€æœ‰ LLM æœåŠ¡ï¼ˆåŒ…æ‹¬ RAGï¼‰çš„å…±åŒé™åˆ¶ã€‚çœŸæ­£çš„è®¡ç®—éš”ç¦»éœ€è¦æ¯ç”¨æˆ·ç‹¬ç«‹æ¨¡å‹å®ä¾‹ï¼Œæˆæœ¬ä¸å¯æ¥å—ã€‚

2. **GPU ä¾§ä¿¡é“æ”»å‡»**: æœ¬æ–¹æ¡ˆä¸é˜²å¾¡ GPU å†…å­˜ä¾§ä¿¡é“æ”»å‡»ã€‚å¦‚éœ€é˜²å¾¡ï¼Œéœ€ä½¿ç”¨ NVIDIA Confidential Computing (H100+ æ”¯æŒ)ã€‚

3. **timing attack**: ä¸åŒç”¨æˆ·çš„ K/V é•¿åº¦ä¸åŒå¯èƒ½å¯¼è‡´æ¨ç†æ—¶é—´å·®å¼‚ã€‚å¦‚éœ€é˜²å¾¡ï¼Œéœ€æ·»åŠ  padding æˆ–å›ºå®šæ¨ç†æ—¶é—´ã€‚

4. **å†…éƒ¨å¨èƒ**: æœ¬æ–¹æ¡ˆé˜²å¾¡çš„æ˜¯"ä»£ç ç¼ºé™·å¯¼è‡´çš„æ„å¤–æ³„éœ²"å’Œ"å¤–éƒ¨æ”»å‡»è€…çš„ç¼“å­˜é”®çŒœæµ‹"ã€‚ä¸é˜²å¾¡æ‹¥æœ‰ä»£ç ä¿®æ”¹æƒé™çš„å†…éƒ¨æ¶æ„å¼€å‘è€…ã€‚

5. **pickle å®‰å…¨**: æœ¬æ–¹æ¡ˆæœªå®Œå…¨è§£å†³ pickle ååºåˆ—åŒ–çš„å®‰å…¨é£é™©ã€‚ç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨ `safetensors` æˆ–è‡ªå®šä¹‰åºåˆ—åŒ–æ ¼å¼æ›¿ä»£ pickleã€‚
