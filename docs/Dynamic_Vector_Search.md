# DKI 动态向量检索方案

## 概述

DKI 支持多种向量检索方案，适应不同的上层应用场景：

| 方案         | 适用场景                  | 优点             | 缺点           |
| ------------ | ------------------------- | ---------------- | -------------- |
| **pgvector** | 已有向量索引的 PostgreSQL | 高性能，原生支持 | 需要预计算向量 |
| **dynamic**  | 无预计算向量的数据库      | 零配置，自动处理 | 首次检索较慢   |
| **none**     | 简单场景                  | 无依赖           | 检索质量较低   |

## 动态向量检索 (Dynamic)

当上层应用的数据库没有预计算的向量字段时，DKI 使用动态向量处理方案。

### 工作流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        动态向量检索流程                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户查询: "推荐一家素食餐厅"                                                 │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Step 1: 从数据库加载用户历史消息                                     │    │
│  │  SELECT * FROM messages WHERE user_id = ? ORDER BY created_at DESC  │    │
│  │  → 返回 200 条消息                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Step 2: 策略选择 (基于消息数量)                                      │    │
│  │  - < 100 条: lazy (实时计算)                                         │    │
│  │  - 100-1000 条: hybrid (BM25 + embedding)                           │    │
│  │  - > 1000 条: batch (预计算)                                         │   │
│  │  → 选择 hybrid 策略                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘    │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Step 3: BM25 初筛                                                  │    │
│  │  - 对所有消息进行 BM25 评分                                          │    │
│  │  - 选取 top-40 候选 (top_k * 4)                                     │    │
│  │  → 40 条候选消息                                                    │    │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                    │
│       ▼                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Step 4: Embedding 重排序                                            │   │
│  │  - 计算查询的 embedding                                              │   │
│  │  - 计算候选消息的 embedding (检查缓存)                                │   │
│  │  - 计算余弦相似度                                                    │   │
│  │  - 选取 top-10                                                      │   │
│  │  → 10 条最相关消息                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                    │
│       ▼                                                                    │
│  返回相关历史消息 → DKI 注入                                                 │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

### 三种策略详解

#### 1. Lazy 策略 (实时计算)

适用场景: 消息数量 < 100

```python
# 流程
for message in messages:
    embedding = compute_embedding(message.content)  # 实时计算
    score = cosine_similarity(query_embedding, embedding)

# 返回 top-k
```

优点:

-   简单直接
-   无需预处理

缺点:

-   消息多时延迟高

#### 2. Batch 策略 (批量预计算)

适用场景: 消息数量 > 1000，或首次加载

```python
# 预计算阶段 (后台任务)
for batch in batches(messages, size=100):
    embeddings = compute_embeddings_batch(batch)
    cache.store(embeddings)

# 检索阶段
for message in messages:
    embedding = cache.get(message.id)  # 从缓存获取
    score = cosine_similarity(query_embedding, embedding)
```

优点:

-   检索速度快
-   适合大数据量

缺点:

-   需要预计算时间
-   需要存储空间

#### 3. Hybrid 策略 (BM25 + Embedding)

适用场景: 消息数量 100-1000 (推荐)

```python
# Step 1: BM25 初筛
bm25 = BM25Okapi(tokenized_messages)
bm25_scores = bm25.get_scores(query_tokens)
candidates = top_n(messages, bm25_scores, n=top_k * 4)

# Step 2: Embedding 重排序
for candidate in candidates:
    embedding = compute_or_cache(candidate.content)
    score = cosine_similarity(query_embedding, embedding)

# 返回 top-k
```

优点:

-   平衡速度和质量
-   BM25 快速过滤无关内容
-   只对候选计算 embedding

缺点:

-   比纯向量检索略慢

### Embedding 缓存

动态向量处理使用多级缓存减少重复计算：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Embedding 缓存架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  查询 embedding                                                             │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  L1: 内存 LRU 缓存                                                   │   │
│  │  - 容量: 100,000 条                                                  │   │
│  │  - 命中率: ~80%                                                      │   │
│  │  - 延迟: < 1ms                                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│       │ miss                                                                │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  L2: 计算并缓存                                                      │    │
│  │  - 调用 embedding API                                               │    │
│  │  - 存入 L1 缓存                                                     │    │
│  │  - 延迟: 50-200ms                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 配置示例

```yaml
vector_search:
    enabled: true
    type: dynamic # 使用动态向量处理

    dynamic:
        # 检索策略
        strategy: hybrid # lazy | batch | hybrid

        # Embedding 模型
        embedding_model: text-embedding-ada-002

        # Embedding API (可选)
        api_url: https://api.openai.com/v1
        api_key: your_api_key

    # 检索参数
    top_k: 10
    similarity_threshold: 0.5
```

### 性能对比

| 策略             | 100 条消息 | 500 条消息 | 2000 条消息 |
| ---------------- | ---------- | ---------- | ----------- |
| lazy             | 5s         | 25s        | 100s        |
| hybrid           | 2s         | 3s         | 5s          |
| batch (预计算后) | 0.1s       | 0.1s       | 0.1s        |

### 最佳实践

1. **默认使用 hybrid 策略**

    - 适用于大多数场景
    - 平衡速度和质量

2. **消息量大时考虑 batch**

    - 后台定时预计算
    - 新消息增量计算

3. **配置合适的 BM25 候选数**

    - 默认: top_k \* 4
    - 可根据实际效果调整

4. **监控缓存命中率**
    - 命中率低于 50% 时考虑增加缓存容量
    - 或使用 batch 策略预计算

## pgvector 方案

如果上层应用的 PostgreSQL 已安装 pgvector 扩展，可以使用原生向量检索：

```yaml
vector_search:
    enabled: true
    type: pgvector
    embedding_field: embedding # 向量字段名
    embedding_dim: 1536
```

要求:

1. PostgreSQL 安装 pgvector 扩展
2. 消息表有向量字段
3. 上层应用负责计算和存储向量

## 方案选择建议

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        向量检索方案选择                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  上层应用数据库有向量字段?                                                    │
│       │                                                                     │
│       ├── 是 → 使用 pgvector (最佳性能)                                      │
│       │                                                                     │
│       └── 否 → 消息量多大?                                                   │
│                   │                                                         │
│                   ├── < 100 条/用户 → lazy (简单)                            │
│                   │                                                         │
│                   ├── 100-1000 条/用户 → hybrid (推荐)                       │
│                   │                                                         │
│                   └── > 1000 条/用户 → batch (需要预计算)                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
