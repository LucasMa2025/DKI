# DKI Plugin Architecture - 插件架构说明

## 核心定位

**DKI 是 LLM 的插件**，不是独立的聊天服务。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        DKI 作为 LLM 插件的定位                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  上层应用 (第三方系统 / 未知)                                                │
│  ├── 自己的用户系统 (users 表)                                              │
│  ├── 自己的消息数据库 (messages 表)                                         │
│  ├── 自己的 Chat UI                                                        │
│  └── 自己的业务逻辑                                                         │
│       │                                                                     │
│       │ 用户输入 (原始文本，不含任何 prompt 构造)                            │
│       │ + user_id + session_id                                             │
│       ▼                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  DKI 插件                                                           │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  1. 通过适配器读取上层应用的数据库                              │  │   │
│  │  │     ├── 用户偏好 (上层应用的 user_preferences 表)              │  │   │
│  │  │     └── 历史消息 (上层应用的 messages 表)                      │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  2. DKI 注入处理                                               │  │   │
│  │  │     ├── 偏好 → K/V 计算 → 负位置注入 (Attention Hook)          │  │   │
│  │  │     └── 历史 → 检索相关 → 正位置拼装 (输入后) + 提示词         │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  3. 调用 LLM 推理 (带 K/V 注入)                                │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│       │                                                                     │
│       │ 返回响应                                                            │
│       ▼                                                                     │
│  上层应用                                                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 数据流

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           DKI 数据流                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  输入:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  - query: str          # 用户原始输入 (不含任何 prompt)              │   │
│  │  - user_id: str        # 用户标识 (用于读取偏好)                     │   │
│  │  - session_id: str     # 会话标识 (用于读取历史)                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  DKI 内部处理:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Step 1: 读取外部数据 (通过适配器)                                   │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  adapter.get_user_preferences(user_id)                        │  │   │
│  │  │  → 返回: List[UserPreference]                                 │  │   │
│  │  │  → 来源: 上层应用的数据库                                      │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  adapter.get_session_history(session_id)                      │  │   │
│  │  │  → 返回: List[ChatMessage]                                    │  │   │
│  │  │  → 来源: 上层应用的数据库                                      │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  adapter.search_relevant_history(user_id, query)              │  │   │
│  │  │  → 返回: List[ChatMessage] (相关历史)                         │  │   │
│  │  │  → 来源: 上层应用的数据库 (可能需要向量检索)                   │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Step 2: DKI 注入处理                                               │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  偏好注入 (负位置 K/V)                                         │  │   │
│  │  │  ├── 偏好文本 → Tokenize → 模型前向 → 提取 K/V                │  │   │
│  │  │  ├── K/V 缓存 (偏好稳定，可复用)                               │  │   │
│  │  │  └── 注入位置: 负位置 (概念上在输入"之前")                     │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  历史注入 (正位置后缀)                                         │  │   │
│  │  │  ├── 检索相关历史消息                                          │  │   │
│  │  │  ├── 格式化为提示词 (带信任引导)                               │  │   │
│  │  │  └── 拼接到用户输入之后 (正位置)                               │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Step 3: LLM 推理                                                   │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  model.forward_with_kv_injection(                             │  │   │
│  │  │      prompt = query + history_suffix,  # 正位置               │  │   │
│  │  │      injected_kv = preference_kv,      # 负位置               │  │   │
│  │  │      alpha = gating_decision.alpha,                           │  │   │
│  │  │  )                                                            │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  输出:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  - response: str       # LLM 生成的响应                             │   │
│  │  - metadata: dict      # DKI 工作数据 (用于监控)                    │   │
│  │    ├── alpha: float                                                 │   │
│  │    ├── preference_tokens: int                                       │   │
│  │    ├── history_tokens: int                                          │   │
│  │    ├── cache_hit: bool                                              │   │
│  │    └── latency_ms: float                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 组件职责

### 1. 外部数据适配器 (IUserDataAdapter)

**职责**: 读取上层应用的数据库，获取用户偏好和历史消息

```python
class IUserDataAdapter(ABC):
    """
    读取上层应用数据库的接口
    
    注意: 这是读取外部系统的数据，不是 DKI 自己的数据存储
    """
    
    @abstractmethod
    async def get_user_preferences(self, user_id: str) -> List[UserPreference]:
        """从上层应用的数据库读取用户偏好配置"""
        pass
    
    @abstractmethod
    async def get_session_history(self, session_id: str, limit: int) -> List[ChatMessage]:
        """从上层应用的数据库读取会话历史"""
        pass
    
    @abstractmethod
    async def search_relevant_history(self, user_id: str, query: str) -> List[ChatMessage]:
        """从上层应用的数据库检索相关历史"""
        pass
```

### 2. DKI 核心 (DKIPlugin)

**职责**: 接收原始输入，通过适配器读取数据，执行注入，调用 LLM

```python
class DKIPlugin:
    """
    DKI 插件核心
    
    作为 LLM 的插件，接收原始用户输入，执行注入后调用 LLM
    """
    
    def __init__(
        self,
        model_adapter: BaseModelAdapter,      # LLM 适配器
        user_data_adapter: IUserDataAdapter,  # 外部数据适配器
    ):
        self.model = model_adapter
        self.data_adapter = user_data_adapter
    
    async def chat(
        self,
        query: str,           # 原始用户输入 (不含任何 prompt)
        user_id: str,         # 用户标识
        session_id: str,      # 会话标识
    ) -> DKIResponse:
        """
        DKI 增强的聊天
        
        1. 通过适配器读取外部数据
        2. 执行 DKI 注入
        3. 调用 LLM 推理
        """
        # Step 1: 读取外部数据
        preferences = await self.data_adapter.get_user_preferences(user_id)
        history = await self.data_adapter.search_relevant_history(user_id, query)
        
        # Step 2: DKI 注入处理
        # ... (偏好 K/V 注入 + 历史后缀拼装)
        
        # Step 3: LLM 推理
        response = self.model.forward_with_kv_injection(...)
        
        return response
```

### 3. 监控 API

**职责**: 提供 DKI 工作数据的监控接口，不是对外聊天服务

```python
# 监控 API 端点
GET  /v1/stats          # DKI 工作统计
GET  /v1/logs           # 注入日志
GET  /v1/health         # 健康检查
GET  /v1/cache/stats    # 缓存统计
GET  /v1/injection/history  # 注入历史记录
```

### 4. 示例 Chat UI

**职责**: 演示如何使用 DKI 插件，自带简单数据存储供适配器读取

```
示例 Chat UI
├── 简单的用户管理 (演示用)
├── 简单的消息存储 (演示用)
├── 调用 DKI 插件
└── 展示 DKI 工作效果
```

## 使用方式

### 方式 1: 作为 Python 库使用

```python
from dki import DKIPlugin
from dki.adapters import PostgreSQLAdapter

# 1. 配置外部数据适配器 (连接上层应用的数据库)
adapter = PostgreSQLAdapter(
    connection_string="postgresql://user:pass@host:5432/app_db",
    users_table="users",
    messages_table="chat_messages",
    preferences_table="user_preferences",
)

# 2. 创建 DKI 插件
dki = DKIPlugin(
    model_adapter=vllm_adapter,
    user_data_adapter=adapter,
)

# 3. 在上层应用中调用
response = await dki.chat(
    query="推荐一家餐厅",  # 原始用户输入
    user_id="user_123",
    session_id="session_456",
)
```

### 方式 2: 作为服务使用 (带监控)

```bash
# 启动 DKI 服务 (包含监控 API)
python -m dki.server --config config.yaml

# 监控 API
curl http://localhost:8080/v1/stats
curl http://localhost:8080/v1/health
```

## 与 RAG 的本质区别

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        DKI vs RAG 本质区别                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  RAG (Token 级别):                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  输入 = [检索内容 tokens] + [用户查询 tokens]                        │   │
│  │                                                                     │   │
│  │  问题:                                                              │   │
│  │  - 检索内容占用上下文窗口 (Token Budget 消耗)                        │   │
│  │  - 注意力计算 O((n_retrieval + n_query)²)                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  DKI (K/V 级别):                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  输入 = [用户查询 tokens]                                            │   │
│  │  注入 = K' = [K_preference | K_query], V' = [V_preference | V_query] │   │
│  │                                                                     │   │
│  │  优势:                                                              │   │
│  │  - 偏好 K/V 不占用 Token Budget (免费!)                              │   │
│  │  - 负位置注入: 偏好在概念上"先于"查询存在                            │   │
│  │  - α 控制: 连续调节记忆影响强度                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  混合策略:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  - 偏好 (短、稳定) → K/V 注入 (负位置，不占 token)                   │   │
│  │  - 历史 (长、动态) → 后缀提示词 (正位置，占 token 但可引用)          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
